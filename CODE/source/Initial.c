
#include "Initial.h"

//===========================================================================
// 函数名称: Sub_CMPx_Calibration											=
// 函数功能: OPA，CMP 校准子程序											=
// 入口参数: *pCMPCx：被校准的寄存器地址；mode：1=OPA，0=CMP				=
// 出口参数: 无																=
//===========================================================================
//added on 2017.11.16 by Jammas
void Sub_CMPx_Calibration (volatile unsigned char *pCMPCx, unsigned char mode)
{
	//Debug 时，需要用 Volatile 修饰，正常时可以不用
	volatile unsigned char r_Value_AOF_L;
	volatile unsigned char r_Value_AOF_H;
	volatile unsigned char r_CMPX_CnCX;				//比较器或者运放输出状态保存位
	volatile unsigned char r_MaxValue;
	
#define		C_CALIBRATION_DELAY	1000		//单位：指令时间，根据实际电路调整	
#define		_ONLY_CALIBRATED_EXIT	1		//1: 只有成功校准好才退出，其他：校验一遍后退出

#if _ONLY_CALIBRATED_EXIT == 1
_Lable_Calibrate_Again_0:
#endif

	if (mode)
	{
		//--- AOF[5:0] 从小到大
		(*pCMPCx) = 0b10000000; 					//OPA calibration
		r_MaxValue =0b00111111;
	}
	else
	{
		//--- CxOF[4:0] 从小到大
		(*pCMPCx) = 0b01000000; 
		r_MaxValue =0b00011111;
	}
	GCC_DELAY(C_CALIBRATION_DELAY);		//---延时固定一定时间，检测比较器或者运放输出状态
		
	r_Value_AOF_L = 0;
	r_CMPX_CnCX = 0;	
	if (mode)
	{
		if (_opac0 & 0x01)
			r_CMPX_CnCX = 1;
	}
	else
	{
		if ((*pCMPCx) & 0x80)
			r_CMPX_CnCX = 0x80;
	}
	
	while(1)
	{
		GCC_CLRWDT();
		(*pCMPCx) ++;
		r_Value_AOF_L ++;
		GCC_DELAY(C_CALIBRATION_DELAY);	//---延时固定一定时间，检测比较器或者运放输出状态
		if (mode)
		{
			if (r_CMPX_CnCX != (_opac0 & 0x01))
				break;						//成功校准，退出
		}
		else
		{
			if (r_CMPX_CnCX != ((*pCMPCx) & 0x80))
				break;						//成功校准，退出
		}
		if (r_Value_AOF_L==r_MaxValue)
		{
#if _ONLY_CALIBRATED_EXIT == 1
			goto _Lable_Calibrate_Again_0;			//不成功校准，继续
#else
			break;							//不成功校准，退出
#endif
		}
	}

#if _ONLY_CALIBRATED_EXIT == 1
_Lable_Calibrate_Again_1:
#endif

	if (mode)
	{
		//--- AOF[5:0] 从大到小
		(*pCMPCx) = 0b10111111; 					//OPA calibration
	}
	else
	{
		//--- CxOF[4:0] 从大到小
		(*pCMPCx) = 0b01011111; 
	}
	GCC_DELAY(C_CALIBRATION_DELAY);		//---延时固定一定时间，检测比较器或者运放输出状态
	
	r_Value_AOF_H = r_MaxValue;
	r_CMPX_CnCX = 0;
	if (mode)
	{
		if (_opac0 & 0x01)
			r_CMPX_CnCX = 1;
	}
	else
	{
		if ((*pCMPCx) & 0x80)
			r_CMPX_CnCX = 0x80;
	}
	
	while(1)
	{
		GCC_CLRWDT();
		(*pCMPCx) --;
		r_Value_AOF_H --;
		GCC_DELAY(C_CALIBRATION_DELAY);	//---延时固定一定时间，检测比较器或者运放输出状态
		if (mode)
		{
			if (r_CMPX_CnCX != (_opac0 & 0x01))
				break;						//成功校准，退出
		}
		else
		{
			if (r_CMPX_CnCX != ((*pCMPCx) & 0x80))
				break;						//成功校准，退出
		}
		if (!r_Value_AOF_H)
		{
#if _ONLY_CALIBRATED_EXIT == 1
			goto _Lable_Calibrate_Again_1;			//不成功校准，继续
#else
			break;							//不成功校准，退出
#endif
		}
	}
	
	//----取平均值
	r_Value_AOF_H += r_Value_AOF_L;
	if (mode)
	{
		(*pCMPCx) &= 0b11000000;				//---设置校准值,并转为OPA正常模式
		(*pCMPCx) |= (r_Value_AOF_H/2)&0x3f;		//---设置校准值,并转为OPA正常模式
		(*pCMPCx) &= 0b01111111;				//---设置校准值,并转为OPA正常模式
	}
	else
	{
		(*pCMPCx) &= 0b11100000;				//---设置校准值,并转为CMP正常模式
		(*pCMPCx) |= (r_Value_AOF_H/2)&0x1f;		//---设置校准值,并转为CMP正常模式
		(*pCMPCx) &= 0b10111111;				//---设置校准值,并转为CMP正常模式
	}
}

//===========================================================================
// 函数名称: Sub_CMPx_Initialation											=
// 函数功能: OPA，CMP 初始化子程序											=
// 入口参数: 无																=
// 出口参数: 无																=
//===========================================================================
//added on 2017.11.17 by Jammas
void Sub_CMPx_Initialation (void)
{
	//=====0===== OPA 相关寄存器初始化 =======================================
	// |---------------------------------------------------------------------|
	// |						OPAC0 寄存器								 |
	// |---------------------------------------------------------------------|
	// |Bit		7		6		5		4		3		2		1		0	 |
	// |---------------------------------------------------------------------|
	// |Name	OPAM1	OPAM0	OPAG2	OPAG1	OPAG0	SWR2	SWR1	OPAX |
	// |---------------------------------------------------------------------|
	// |R/W		R/W		R/W		R/W		R/W		R/W		R/W		R/W		R	 |
	// |---------------------------------------------------------------------|
	// |POR		0		0		0		0		0		0		0		x	 |
	// |---------------------------------------------------------------------|
	//	Bit 7~6 OPAM1~OPAM0：OPA 使能/ 除能控制位
	//		00：OPA 除能
	//		01：OPA 使能
	//		10：OPA 使能
	//		11：OPA 除能
	//	Bit 5~3 OPAG2~OPAG0：OPA 增益选择位
	//		000：×5
	//		001：×5
	//		010：×10
	//		011：×15
	//		100：×20
	//		101：×20
	//		110：×20
	//		111：×20
	//	Bit 2 SWR2：OPA R2 开关控制位
	//		0：Off
	//		1：On
	//	Bit 1 SWR1：OPA R1 开关控制位
	//		0：Off
	//		1：On
	//	Bit 0 OPAX：输入失调电压校准模式下运算放大器数字输出
	//		0：正相输入电压 < 反相输入电压
	//		1：正相输入电压 > 反相输入电压
	_opac0 = 0b10100100;			//--OPA Enable;  x20; SWR2:On;	外部反馈电路
	
	//=====1===== CMP0 相关寄存器初始化 ======================================
	// |---------------------------------------------------------------------|
	// |						CMP0C0 寄存器								 |
	// |---------------------------------------------------------------------|
	// |Bit		7		6		5		4		3		2		1		0	 |
	// |---------------------------------------------------------------------|
	// |Name	C0EG1	C0EG0	C0EN	C0CHY	C0O		C0RSW	C0CSW	―	 |
	// |---------------------------------------------------------------------|
	// |R/W		R/W		R/W		R/W		R/W		R/W		R/W		R/W		-	 |
	// |---------------------------------------------------------------------|
	// |POR		0		0		0		0		0		0		0		-	 |
	// |---------------------------------------------------------------------|
	//	Bit 7~6 C0EG1~C0EG0：比较器0 输出的SYNC 中断边沿控制位
	//		00：除能
	//		01：上升沿触发
	//		10：下降沿触发
	//		11：双沿触发
	//	Bit 5 C0EN：比较器0 使能控制位
	//		0：除能
	//		1：使能，比较器0 电源开启
	//		如果该位为0，比较器0 将除能并且不会产生功耗。这将导致比较器0 被关闭。
	//	Bit 4 C0CHY：比较器0 迟滞使能控制位
	//		0：除能
	//		1：使能
	//	Bit 3 C0O：比较器0 去抖数字输出位
	//	Bit 2 C0RSW：比较器0 内部电阻模拟开关控制位
	//		0：Off
	//		1：On
	//	Bit 1 C0CSW：比较器0 内部电容模拟开关控制位
	//		0：Off
	//		1：On
	//	Bit 0 未定义，读为“0”
	//_cmp0c0 = 0b10100000;	//10：SYN+/SYN- 下降沿触发，取消内部电容电阻
	_cmp0c0 = 0x00;
	
	// |---------------------------------------------------------------------|
	// |						CMP0C2 寄存器								 |
	// |---------------------------------------------------------------------|
	// |Bit		7		6		5		4		3		2		1		0	 |
	// |---------------------------------------------------------------------|
	// |Name	-		-		C0DB5	C0DB4	C0DB3	C0DB2	C0DB1	C0DB0|
	// |---------------------------------------------------------------------|
	// |R/W		R/W		R/W		R/W		R/W		R/W		R/W		R/W		R/W	 |
	// |---------------------------------------------------------------------|
	// |POR		-		-		0		0		0		0		0		0	 |
	// |---------------------------------------------------------------------|
	//	Bit 7~6 未定义，读为“0”
	//	Bit 5~0 C0DB5~C0DB0：选择比较器0 输出去抖时间
	//		000000：无去抖
	//		000001：去抖时间 = (0~1) × 1/fSYS
	//		000010：去抖时间 = (1~2) × 1/fSYS
	//		000011：去抖时间 = (2~3) × 1/fSYS
	//		::
	//		101111：去抖时间 = (46~47) × 1/fSYS
	//		11xxxx：去抖时间 = (47~48) × 1/fSYS
	_cmp0c2 = 0b00000011;
	
	// |---------------------------------------------------------------------|
	// |						CMP0C3 寄存器								 |
	// |---------------------------------------------------------------------|
	// |Bit		7		6		5		4		3		2		1		0	 |
	// |---------------------------------------------------------------------|
	// |Name	―		― 	 PPGDL5	 PPGDL4	 PPGDL3	  PPGDL2  PPGDL1  PPGDL0 |
	// |---------------------------------------------------------------------|
	// |R/W		R/W		R/W		R/W		R/W		R/W		R/W		R/W		R/W	 |
	// |---------------------------------------------------------------------|
	// |POR		-		-		0		0		0		0		0		0	 |
	// |---------------------------------------------------------------------|
	//	Bit 7~6 未定义，读为“0”
	//	Bit 5~0 PPGDL5~PPGDL0：选择PPG 触发延迟
	//		000000：无延迟
	//		000001：延迟时间 = 1 × 1/fSYS
	//		000010：延迟时间 = 2 × 1/fSYS
	//		000011：延迟时间 = 3 × 1/fSYS
	//		::
	//		101111：延迟时间 = 47 × 1/fSYS
	//		11xxxx：延迟时间 = 48 × 1/fSYS
	//		注：1. 触发延迟意味着被发送的PPG 触发信号有一定的延迟时间。
	//		2. 在触发延迟期间的PPG 触发将被忽略。
	_cmp0c3 = 0b00000000;

	//=====2===== CMP1 相关寄存器初始化 ======================================
	// |---------------------------------------------------------------------|
	// |						CMP1C0 寄存器								 |
	// |---------------------------------------------------------------------|
	// |Bit		7		6		5		4		3		2		1		0	 |
	// |---------------------------------------------------------------------|
	// |Name	PSPC1E	C1RLEN	C1EN	C1CHY	C1O		C1RV	C1DB1	C1DB0|
	// |---------------------------------------------------------------------|
	// |R/W		R/W		R/W		R/W		R/W		R/W		R/W		R/W		R/W  |
	// |---------------------------------------------------------------------|
	// |POR		0		0		0		0		0		0		0		0	 |
	// |---------------------------------------------------------------------|
	//	Bit 7 PSPC1E：过压发生时PPG 模块停止输出使能/ 除能位
	//		0：除能
	//		1：使能
	//		若使能，当过压情况发生时，PPG 模块输出将无效，PST 位被置0，PRSEN 位
	//		被置0。
	//	Bit 6 C1RLEN：过压发生时RLBF 被置位使能/ 除能位
	//		0：除能
	//		1：使能
	//		若使能，当过压情况发生时，PPG 计数器将从预载寄存器B 重新载入计数值，
	//		RLBF 被置1。
	//	Bit 5 C1EN：比较器1 使能控制位
	//		0：除能
	//		1：使能，比较器1 及其DAC 的电源开启
	//		如果该位为0，比较器1 及其DAC 将除能并且不会产生功耗。这将导致比较器
	//		1 及其DAC 都被关闭。
	//	Bit 4 C1CHY：比较器1 迟滞使能控制位
	//		0：除能
	//		1：使能
	//	Bit 3 C1O：比较器1 去抖数字输出位
	//	Bit 2 C1RV：比较器1 DAC 的参考电压选择
	//		0：VDD 引脚
	//		1：VREF 引脚
	//	Bit 1~0 C1DB1~C1DB0：比较器1 去抖时间选择
	//		00：无去抖
	//		01：去抖时间 = (3~4) × 1/fSYS
	//		10：去抖时间 = (7~8) × 1/fSYS
	//		11：去抖时间 = (15~16) × 1/fSYS
	//_cmp1c0 = 0b00110010;
	_cmp1c0 = 0x00;
	
	// |---------------------------------------------------------------------|
	// |						CMP1C2 寄存器								 |
	// |---------------------------------------------------------------------|
	// |Bit		7		6		5		4		3		2		1		0	 |
	// |---------------------------------------------------------------------|
	// |Name	C1EG1 C1EG0		-		-		-		-		-		-	 |
	// |---------------------------------------------------------------------|
	// |R/W		R/W		R/W		-		-		-		-		-		-	 |
	// |---------------------------------------------------------------------|
	// |POR		0		0		-		-		-		-		-		-	 |
	// |---------------------------------------------------------------------|
	//	Bit 7 6 5 4 3 2 1 0
	//	Name C1EG1 C1EG0 ― ― ― ― ― ―
	//	R/W R/W R/W ― ― ― ― ― ―
	//	POR 0 0 ― ― ― ― ― ―
	//	Bit 7~6 C1EG1~C1EG0：比较器1 输出的过压保护中断边沿控制位
	//		00：除能
	//		01：上升沿触发
	//		10：下降沿触发
	//		11：双沿触发
	//	Bit 5~0 未定义，读为“0”
	//_cmp1c2 = 0b01000000;
	_cmp1c2 = 0x00;
	
	//=====3===== CMP2 相关寄存器初始化 ======================================
	// |---------------------------------------------------------------------|
	// |						CMP2C0 寄存器								 |
	// |---------------------------------------------------------------------|
	// |Bit		7		6		5		4		3		2		1		0	 |
	// |---------------------------------------------------------------------|
	// |Name	C2EG1	C2EG0	C2EN	C2CHY	C2O		C2RV	C2DB1	C2DB0|
	// |---------------------------------------------------------------------|
	// |R/W		R/W		R/W		R/W		R/W		R/W		R/W		R/W		R/W  |
	// |---------------------------------------------------------------------|
	// |POR		0		0		0		0		0		0		0		0	 |
	// |---------------------------------------------------------------------|
	//	Bit 7~6 C2EG1~C2EG0：比较器2 输出的过零中断边沿控制位
	//		00：除能
	//		01：上升沿触发
	//		10：下降沿触发
	//		11：双沿触发
	//	Bit 5 C2EN：比较器2 使能控制位
	//		0：除能
	//		1：使能，比较器2 及其DAC 的电源开启
	//		如果该位为0，比较器2 及其DAC 将除能并且不会产生功耗。这将导致比较器
	//		2 及其DAC 都被关闭。
	//	Bit 4 C2CHY：比较器2 迟滞使能控制位
	//		0：除能
	//		1：使能
	//	Bit 3 C2O：比较器2 去抖数字输出位
	//	Bit 2 C2RV：选择比较器2 DAC 的参考电压
	//		0：VDD 引脚
	//		1：VREF 引脚
	//	Bit 1~0 C2DB1~C2DB0：比较器2 去抖时间选择
	//		00：无去抖
	//		01：去抖时间 = (3~4) × 1/fSYS
	//		10：去抖时间 = (7~8) × 1/fSYS
	//		11：去抖时间 = (15~16) × 1/fSYS
	//_cmp2c0 = 0b10110001;
	_cmp2c0 = 0x00;
	
	//=====4===== CMP3 相关寄存器初始化 ======================================
	// |---------------------------------------------------------------------|
	// |						CMP3C0 寄存器								 |
	// |---------------------------------------------------------------------|
	// |Bit		7		6		5		4		3		2		1		0	 |
	// |---------------------------------------------------------------------|
	// |Name	PSPC3E	―		C3EN	C3CHY	C3O		C3RV	C3DB1	C3DB0|
	// |---------------------------------------------------------------------|
	// |R/W		R/W		-		R/W		R/W		R/W		R/W		R/W		R/W  |
	// |---------------------------------------------------------------------|
	// |POR		0		-		0		0		0		0		0		0	 |
	// |---------------------------------------------------------------------|
	//	Bit 7 PSPC3E：浪涌电压发生时PPG 模块停止输出使能/ 除能位
	//		0：除能
	//		1：使能
	//		若使能， 当浪涌电压情况发生时，PPG 模块输出将无效，PST 位被置0，
	//		PRSEN 位被置0。
	//	Bit 6 未定义，读为“0”
	//	Bit 5 C3EN：比较器3 使能控制位
	//		0：除能
	//		1：使能，比较器3 及其DAC 的电源开启
	//		如果该位为0，比较器3 及其DAC 将除能并且不会产生功耗。这将导致比较器
	//		3 及其DAC 都被关闭。
	//	Bit 4 C3CHY：比较器3 迟滞使能控制位
	//		0：除能
	//		1：使能
	//	Bit 3 C3O：比较器3 去抖数字输出位
	//	Bit 2 C3RV：选择比较器3 DAC 的参考电压
	//		0：VDD 引脚
	//		1：VREF 引脚
	//	Bit 1~0 C3DB1~C3DB0：比较器3 去抖时间选择
	//		00：无去抖
	//		01：去抖时间 = (3~4) × 1/fSYS
	//		10：去抖时间 = (7~8) × 1/fSYS
	//		11：去抖时间 = (15~16) × 1/fSYS
	//_cmp3c0 = 0b00110010;
	_cmp3c0 = 0x00;
	
	// |---------------------------------------------------------------------|
	// |						CMP3C2 寄存器								 |
	// |---------------------------------------------------------------------|
	// |Bit		7		6		5		4		3		2		1		0	 |
	// |---------------------------------------------------------------------|
	// |Name	C3EG1	C3EG0	―		-		-		-		-		-	 |
	// |---------------------------------------------------------------------|
	// |R/W		R/W		R/W		-		-		-		-		-		-	 |
	// |---------------------------------------------------------------------|
	// |POR		0		0		-		-		-		-		-	 	-	 |
	// |---------------------------------------------------------------------|
	//	Bit 7~6 C3EG1~C3EG0：比较器3 输出的浪涌电压保护中断边沿控制位
	//		00：除能
	//		01：上升沿触发
	//		10：下降沿触发
	//		11：双沿触发
	//	Bit 5~0 未定义，读为“0”
	//_cmp3c2 = 0b01000000;			//		01：上升沿触发
	_cmp3c2 = 0x00;
	
	//=====5=====  CMP4 相关寄存器初始化 =====================================
	// |---------------------------------------------------------------------|
	// |						CMP4C0 寄存器								 |
	// |---------------------------------------------------------------------|
	// |Bit		7		6		5		4		3		2		1		0	 |
	// |---------------------------------------------------------------------|
	// |Name	PSPC4E	C4RLEN	C4EN	C4CHY	C4O		C4RV	C4DB1	C4DB0|
	// |---------------------------------------------------------------------|
	// |R/W		R/W		R/W		R/W		R/W		R/W		R/W		R/W		R/W  |
	// |---------------------------------------------------------------------|
	// |POR		0		0		0		0		0		0		0		0	 |
	// |---------------------------------------------------------------------|
	//	Bit 7 PSPC4E：过流发生时PPG 模块停止输出使能/ 除能位
	//		0：除能
	//		1：使能
	//		若使能，当过流情况发生时，PPG 模块输出将无效，PST 位被置0，PRSEN 位
	//		被置0。
	//	Bit 6 C4RLEN：过流发生时RLBF 被置位使能/ 除能位
	//		0：除能
	//		1：使能
	//		若使能，当过流情况发生时，PPG 计数器将从预载寄存器B 重新载入计数值，
	//		RLBF 被置1。
	//	Bit 5 C4EN：比较器4 使能控制位
	//		0：除能
	//		1：使能，比较器1 及其DAC 的电源开启
	//		如果该位为0，比较器4 及其DAC 将除能并且不会产生功耗。这将导致比较器
	//		4 及其DAC 都被关闭。
	//	Bit 4 C4CHY：比较器4 迟滞使能控制位
	//		0：除能
	//		1：使能
	//	Bit 3 C4O：比较器4 去抖数字输出位
	//	Bit 2 C4RV：选择比较器4 DAC 的参考电压
	//		0：VDD 引脚
	//		1：VREF 引脚
	//	Bit 1~0 C4DB1~C4DB0：比较器4 去抖时间选择
	//		00：无去抖
	//		01：去抖时间 = (3~4) × 1/fSYS
	//		10：去抖时间 = (7~8) × 1/fSYS
	//		11：去抖时间 = (15~16) × 1/fSYS
	//_cmp4c0 = 0b00110010;
	_cmp4c0 = 0x00;
	
	// |---------------------------------------------------------------------|
	// |						CMP4C2 寄存器								 |
	// |---------------------------------------------------------------------|
	// |Bit		7		6		5		4		3		2		1		0	 |
	// |---------------------------------------------------------------------|
	// |Name	C4EG1	C4EG0	―		-		-		-		C4PC1	C4PC0|
	// |---------------------------------------------------------------------|
	// |R/W		R/W		R/W		-		-		-		-		R/W		R/W	 |
	// |---------------------------------------------------------------------|
	// |POR		0		0		-		-		-		-		0	 	0	 |
	// |---------------------------------------------------------------------|
	//	Bit 7~6 C4EG1~C4EG0：比较器4 输出的过流保护中断边沿控制位
	//		00：除能
	//		01：上升沿触发
	//		10：下降沿触发
	//		11：双沿触发
	//	Bit 5~2 未定义，读为“0”
	//	Bit 1~0 C4PC1~C4PC0：比较器4 同相输入端选择位
	//		0x：IS0 引脚
	//		1x：OPA 输出
	//_cmp4c2 = 0b10000000;        //----下降沿出发...IS0检测
	_cmp4c2 = 0x00;
	
	//=====6===== 比较器参考 DAC 寄存器初始化 ================================
	// |---------------------------------------------------------------------|
	// |						CMPnDA 寄存器 (n=1~4)						 |
	// |---------------------------------------------------------------------|
	// |Bit		7		6		5		4		3		2		1		0	 |
	// |---------------------------------------------------------------------|
	// |Name	D7		D6		D5		D4		D3		D2		D1		D0	 |
	// |---------------------------------------------------------------------|
	// |R/W		R/W		R/W		R/W		R/W		R/W		R/W		R/W		R/W  |
	// |---------------------------------------------------------------------|
	// |POR		0		0		0		0		0		0		0		0	 |
	// |---------------------------------------------------------------------|	
	//	Bit 7~0 D7~D0：CMPn DAC 数据寄存器bit 7 ~ bit 0
	//		8-bit DAC 数据位
	//		CMPn DAC 输出电压 = (DAC 参考电压) × (D[7:0])/256
	
	// 反压比较器 CMP1 负端参考电压
	_cmp1da = 170;		//C_CMP1_DAC_VXX		170		// = (3.6V/AVDD_AVREF)*256
	
	// 过零比较器 CMP2 负端参考电压
	_cmp2da = 50;		//C_CMP2_DAC_VXX		50 		// = (0.3V/AVDD_AVREF)*256
	
	// 浪涌比较器 CMP3 负端参考电压
	_cmp3da = 200;		//C_CMP3_DAC_VXX		200		// = (3.3V/AVDD_AVREF)*256
	
	// 过流比较器 CMP4 负端参考电压
	_cmp4da = 150;		//C_CMP4_DAC_VXX		150		// 0.3V*10-Iov * R -电流放大10倍-
	
}

//===========================================================================
// 函数名称: Sub_CMPx_Calibration												=
// 函数功能: OPA，CMP 校准子程序														=
// 入口参数: *pCMPCx：被校准的寄存器地址；mode：1=OPA，0=CMP									=
// 出口参数: 无																	=
//===========================================================================
//added on 2017.11.16 by Jammas
void OPA_CMPx_INITIAL ()
{
	//开始进行运放和比较器的校准
	_opac0=0b10100000;			//--OPA Enable;  外部反馈电路
	Sub_CMPx_Calibration(&_opac1 , 1);
	_c0en=1;					//--CMP0C0.5 -- 0:除能 ; 1: 使能 ;
	Sub_CMPx_Calibration(&_cmp0c1, 0);
	_c1en=1;					//--CMP1C0.5 -- 0:除能 ; 1: 使能 ;
	Sub_CMPx_Calibration(&_cmp1c1, 0);
	_c2en=1;					//--CMP2C0.5 -- 0:除能 ; 1: 使能 ;
	Sub_CMPx_Calibration(&_cmp2c1, 0);
	_c3en=1;					//--CMP3C0.5 -- 0:除能 ; 1: 使能 ;
	Sub_CMPx_Calibration(&_cmp3c1, 0);
	_c4en=1;					//--CMP4C0.5 -- 0:除能 ; 1: 使能 ;
	Sub_CMPx_Calibration(&_cmp4c1, 0);
	//校准完后，再进行运放和比较器的其它寄存器设置
	Sub_CMPx_Initialation ();
	//.... Total escaped time is about 220mS
}
//==============================================
//**********************************************
// RESET_INITIAL-- START
//==============================================
void RESET_INITIAL()
{
	SYS_INITIAL();
	IO_INITIAL();
	OPA_CMPx_INITIAL ();
	CTM0_INITIAL();
//	CTM1_INITIAL();
	#if _PWM_ENABLE == 1
	PTM0_INITIAL();
	#endif
//	PPG_INITIAL();
	ADC_INITIAL();
	INTERRUPT_INITIAL();
	
	#if	_UART_ENABLE == 1
	UART_INITIAL();
	#endif
	RAM_INITIAL();
}

//==============================================
//**********************************************
// SYS_INITIAL-- START
//==============================================
void SYS_INITIAL()
{
	//;-----------
	/*--remark:-
	//;--------SCC
	_scc7=0;						// SCC[7:5]---系统时钟选择; 000: FH ; 001: FH/2 ; 010:FH/4; 011:FH/8
	_scc6=0;						// --- 100: FH/16 ; 101: FH/32 ; 110:FH/64 ; 111:fsub
	_scc5=0;
	_scc4=0;						// SCC[4:2]---未定义;READ 0
	_scc3=0;
	_scc2=0;
	_fhiden=0;						// SCC.1---CPU执行HALT指令后是否激活HIRC--- 0: 除能(不激活即HALT指令后关闭HIRC) 1:使能()
	_fsiden=0;						// SCC.0---CPU执行HALT指令后是否激活LIRC--- 0: 除能(不激活即HALT指令后关闭LIRC) 1:使能()
	
	//;--------HIRCC
	_hircc7~2=0;					// HIRCC[7:2]---未定义;READ 0
	_hircf=0;						// HIRCC.1--- HIRC振荡器是否稳定---0:不稳定 ; 1: 稳定
	_hircen=1;						// HIRCC.0--- HIRC振荡器使能位---0:除能 ; 1: 使能
	
	//;--------WDTC
	_we4~0=10101;					// WDTC[7:3]---WDT使能位-- 10101&01010:使能 ; 其他值 MCU复位
	_ws2=1;						// WDTC[2:1]--- 000: 2^8/fLIRC ; 001: 2^10/fLIRC ; 010:2^12/fLIRC; 011:2^14/fLIRC
	_ws1=1;						// --- 100: 2^15/fLIRC; 101: 2^16/fLIRC ; 110:2^17/fLIRC ; 111:2^18/fLIRC
	_ws0=1;
	
	//;--------RSTFC
	_lvrf=0;						// RSTFC.2--- LVR 复位发生标志--// 当低电压复位 条件发生时 此位置1, 只能软件清除
	_lrf=0;						// RSTFC.1--- LVRC控制寄存器软件复位标志位-- 如果LVRC被定义为任何非定义的LCR值,此位会被置1, 只能软件清除
	_wrf=0;						// RSTFC.0--- 发生WDTC软件复位是此位置1
	
	//;--------LVRC
	_lvs7~0 =01010101;				// LVRC[7:0]---LVR复位电压选择 0x55&0x33&0x99&0xaa :3.15V ; 其他值 MCU复位
	
	//;--------LVDC
	// LVDC[7:6]--未使用
	_lvd0          					// LVDC.5---LVD输出标志: 0: 未检测到低压输出标志 ; 1: 检测到低电压
	_lvden=1;                				// LVDC.4---LVD输出标志: 0: 未检测到低压输出标志 ; 1: 检测到低电压
	_vbgen=1;               				// LVDC.3---LVD输出标志: 0: 未检测到低压输出标志 ; 1: 检测到低电压
	_vlvd2=0;						// LVDC[2:0]--选择LVD电压位: 000~100 :未使用
	_vlvd1=0;               				 // 101: 3.3V  ;  110: 3.6V  ;  111: 4.0V
	_vlvd0=0;
	*/
//	_scc = 0x00;						// FSYS = FH
	_scc = 0b00100000;						// FSYS = FH/2=8m
	_hircc = 0x01;					// HIRC 控制器使能
	
	while(!_hircf)					// 检测HIRC振荡器是否稳定--- 0: 未稳定,  1: 稳定
	{
		GCC_CLRWDT();
	}
	
	_wdtc = 0xaf;					// WDT 溢出周期 为 2^18/fLIRC
	_lvrc = 0x55;					// LVR复位电压 3.15V
	_lvdc = 0x1d;					// LVD ENABLE, vbgen Enable , LVD: 3.3V
}

//==============================================
//**********************************************
// IO_INITIAL-- START
//==============================================
void IO_INITIAL()
{
	//;---------RX, SCL, SDA 选配
	/*--remark:-
	//;--------CTRL
	_ctrl.7 ;						// CTRL.7---未定义;
	_tdccs2=1;   					// CTRL.6  与 TDC 中的 _tdccs1 和_tdccs0 一起使用
	_rxpc=0;						// CTRL.5---RX复用选择   0: PA2;  1：PB1
	_sclpc=0;						// CTRL.4---SCL复用选择  0: PA2;  1：PA7
	_sdapc=0;						// CTRL.3---SDA复用选择  0: PA0;  1：PA6
	_ctrl[2:0]=0;					// CTRL[2:0]---未定义
	*/
	_ctrl = 0b00100000;				// RX 选择复用在 PB1 ; SCL 复用在PA2 ; SDA 复用在PA0

	//;---------IO配置--PA
	/*--remark:-
	//;--------PAS0 功能选择
	_pas07=1; 						// PAS0[7:6]---PA3功能定义; 00: PA3/PTCK0 ; 01: PT0 ; 10:PCK ; 11:AN2
	_pas06=1;
	_pas05=0;						 // PAS0[5:4]---PA2功能定义; 00: PA2/INT0 ; 01：RX ; 10: CTP1 ; 11: SCL
	_pas04=1;
	_pas03=0; 						// PAS0[3:2]---PA1功能定义; 00: PA1 ; 01: OPO ; 10: AN1 ; 11: OPO/AN1
	_pas02=1;
	_pas01=0; 						// PAS0[1:0]---PA0功能定义; 00: PA0 ; 01：TX ;  10: SDA ; 11: AN8
	_pas00=1;

	//;--------PAS1
	_pas17=1; 						// PAS1[7:6]---PA7功能定义; 00: PA7/INT1/CTCK0 ; 01: CTP0 ; 10: SCL ; 11: AN6
	_pas16=1;
	_pas15=0;						 // PAS1[5:4]---PA6功能定义; 00: PA6 ; 01: SDA ; 10: TD3 ; 11: AN5
	_pas14=1;
	_pas13=0; 						// PAS1[3:2]---PA5功能定义; 00: PA5 ; 01: PCK ; 10: TD2 ; 11: AN4
	_pas12=1;
	_pas11=0; 						// PAS1[1:0]---PA4功能定义; 00: PA4/CTCK1 ; 01: TD1 ; 10: VREF ; 11: AN3
	_pas10=1;
	*/

	_pas0 = 0b00001100;			//pa3; pa2; pa1:AN1 检测充电电流CHARGE_I; pa0;
	_pas1 = 0b00110000;			//pa7; PA6：AN6 BAT_V;        pa5;  pa4;

	_papu = 0b00000100;					//PA1口上拉电阻使能
	_pac  = 0b01000110;					//pa口输入输出控制 0：输出 1：输入
	_pa   = 0b10000000;
	P_OPEN_C = 0;
	P_OPEN = 0;/* 1:打开电源供电 */

	//;---------IO配置--PB
	/*--remark:-
	//;--------PBS0
	_PBS007~4=0;				// PBS0[7:4]---未定义;READ 0

	_pbs03=0;					// PBS0[3:2]---PB1功能定义; 00&01&10: PB1 ; 11: RX
	_pbs02=1;
	_pbs01=0;					// PBS0[1:0]---PB0功能定义; 00&01&10: PB0 ; 11: TX
	_pbs00=1;
	*/
	_pbs0 = 0b00000000;				//PB1:RX;	PB0:TX   PBS0[7:4]---未定义
	_pbpu = 0b00001100;
	_pbc  = 0b00001100;				// 0：输出 1：输入         PBC[7:4]---未定义
	_pb   = 0b00000000;

	//;---------IO配置--PC
	/*--remark:-
	//;--------PCS0
	_pcs07=0;					// PCS0[7:6]---PC3功能定义; 00&01: PC3 ; 10: SYN- ; 11: AN0
	_pcs06=0;
	_pcs05=1;					// PCS0[5:4]---PC2功能定义; 00&01&10: PC2 ; 11: IS0
	_pcs04=1;
	_pcs03=0;					// PCS0[3:2]---PC1功能定义; 00&01: PC1 ; 10: ACD ; 11: AN7
	_pcs02=1;
	_pcs01=0;					// PCS0[1:0]---PC0功能定义; 00&01&10: PC0 ; 11: IS1
	_pcs00=1;

	//;--------PCS1
	_pcs17~2=0;				// PCS1[7:2]---未定义;

	_pcs11=0;					// PCS1[1:0]---PC4功能定义; 00&01&10: PC4 ; 11: SYN+
	_pcs10=1;
	*/
	_pcs0 = 0b00000011; 	//PC3; PC2; PC1; PC0:IS1;
	_pcs1 = 0b00000000;		//PC4
	_pcpu = 0b00000110;		//pc口上拉电阻使能 0：除能 1：使能
	_pcc  = 0b00000110; 	// 0：输出 1：输入
	_pc   = 0b00001000;		//PC2:OPEN
}

//==============================================
//**********************************************
// INTERRUPT_INITIAL-- START
//==============================================
void INTERRUPT_INITIAL()
{
	//;---------INTERRUPT Enable配置
	/*--remark:
	//--------- INTEG
	_int1s1=0;
	_int1s0=1;					//;-- INTEG[3:2]--INT1 PIN 边沿控制 -- 00: 除能;  01：上升沿; 10: 下降沿;  11: 双沿
	_int0s1=0;
	_int0s0=1;					//;-- INTEG[1:0]--INT0 PIN 边沿控制 -- 00: 除能;  01：上升沿; 10: 下降沿;  11: 双沿

	//--------- INTC0
	_cp1f=0;					//;-- INTC0.6
	_cp0f=0;					//;-- INTC0.5
	_int0f=0;					//;-- INTC0.4

	_cp1e=0;					//;-- INTC0.3 --CMP1 中断控制位
	_cp0e=0;					//;-- INTC0.2 --CMP0 中断控制位
	_int0e=0;					//;-- INTC0.1
	_emi=0;					//;-- INTC0.0

	//--------- INTC1
	_syncf=0;					//;-- INTC1.7 --自动记录同步信号次数中断请求标志位
	_cp4f=0;					//;-- INTC1.6 --CMP4 中断标志
	_cp3f=0;					//;-- INTC1.5 --CMP3 中断标志
	_cp2f=0;					//;-- INTC1.4 --CMP2 中断标志

	_synce=0;					//;-- INTC1.3 --自动记录同步信号次数中断控制位
	_cp4e=0;					//;-- INTC1.2 --CMP4 中断控制位
	_cp3e=0;					//;-- INTC1.1 --CMP3 中断控制位
	_cp2e=0;					//;-- INTC1.0 --CMP2 中断控制位

	//--------- INTC2
	_tf=0;					//;-- INTC2.7 --定时/计数溢出中断标志
	_tb1f=0;					//;-- INTC2.6 --时基1 中断标志
	_mf0f=0;					//;-- INTC2.5 --MF0 中断标志
	_iicf=0;					//;-- INTC2.4 --IIC 中断标志

	_te=0;					//;-- INTC2.3 --定时/计数溢出 中断控制位
	_tb1e=0;					//;-- INTC2.2 --时基1         中断控制位
	_mf0e=0;					//;-- INTC2.1 --MF0  中断控制位
	_iice=0;					//;-- INTC2.0 --IIC  中断控制位

	//--------- INTC3
	_mf3f=0;					//;-- INTC3.7 --MF3 中断标志
	_mf2f=0;					//;-- INTC3.6 --MF2 中断标志
	_mf1f=0;					//;-- INTC3.5 --MF1 中断标志
	_urf=0;					//;-- INTC3.4 --UART 中断标志

	_mf3e=0;					//;-- INTC3.3 --MF3  中断控制位
	_mf2e=0;					//;-- INTC3.2 --MF2  中断控制位
	_mf1e=0;					//;-- INTC3.1 --MF1  中断控制位
	_ure=0;					//;-- INTC3.0 --UART  中断控制位

	//--------- MFI0
	//;-- MFI0.7 ----未定义
	_tb0f=0;					//;-- MFI0.6 --时基0 中断标志
	_ptmaf=0;					//;-- MFI0.5 --PTM CCRA 中断标志
	_ptmpf=0;					//;-- MFI0.4 --PTM CCRP 中断标志

	//;-- MFI0.3 --未定义
	_tb0e=0;					//;-- MFI0.2 --时基0  中断控制位
	_ptmae=0;					//;-- MFI0.1 --PTM CCRA  中断控制位
	_ptmpe=0;					//;-- MFI0.0 --PTM CCRP  中断控制位

	//--------- MFI1
	//;-- MFI1.7 ----未定义
	_adf=0;					//;-- MFI1.6 --AD 中断标志
	_ctm0af=0;					//;-- MFI1.5 --CTM0 CCRA 中断标志
	_ctm0pf=0;					//;-- MFI1.4 --CTM0 CCRP 中断标志

	//;-- MFI1.3 ----未定义
	_ade=0;					//;-- MFI1.2 --AD  中断控制位
	_ctm0ae=0;					//;-- MFI1.1 --CTM0 CCRA 中断控制位
	_ctm0pe=0;				//;-- MFI1.0 --CTM0 CCRP 中断控制位

	//--------- MFI2
	//;-- MFI2.7 ----未定义
	_def=0;					//;-- MFI2.6 --EEPROM 中断标志
	_ctm1af=0;					//;-- MFI2.5 --CTM1 CCRA 中断标志
	_ctm1pf=0;					//;-- MFI2.4 --CTM1 CCRP 中断标志

	//;-- MFI2.3 ----未定义
	_dee=0;					//;-- MFI2.2 --EEPROM  中断控制位
	_ctm1ae=0;					//;-- MFI2.1 --CTM1 CCRA 中断控制位
	_ctm1pe=0;				//;-- MFI2.0 --CTM1 CCRP 中断控制位

	//--------- MFI3
	//;-- MFI3.7~6 ----未定义
	_lvf=0;					//;-- MFI3.5 --LVD 中断标志
	_int1f=0;					//;-- MFI3.4 --INT1 中断标志

	//;-- MFI3.3~2 ----未定义
	_lve=0;					//;-- MFI3.1 --LVD 中断控制位
	_int1e=0;					//;-- MFI3.0 --INT1 中断控制位
	*/
	_tbc = 0x50;					//0x50-->0x60, Vol 电压采样延时 2.048ms，采样 64 次
	_integ = 0x00;				//;-- 关闭中断脚功能
	_tb1e = 0;
	_tb0e = 0;
	_intc1 = 0x00;				//;-- CMP2(过零)使能 //; CMP4(过流), CMP3(浪涌), SYNC同步中断  使能 // 短路保护关闭
	_intc0 = 0x01;				//;-- CMP1(过压)使能   //;  CMP0(同步) 使能, //EMI 关闭
//	_mf2e=0;					//;-- CTM1

}

//==============================================
//**********************************************
// RAM_INITIAL-- CLEAR 0
//==============================================
void RAM_INITIAL()
{
	_mp1h=0;
	for(_mp1l=0x80,_acc=0;_acc<128;_acc++,_mp1l++)
	{
		_iar1=0;
	}
	_mp1h=1;

	for(_mp1l=0x80,_acc=0;_acc<128;_acc++,_mp1l++)
	{
		_iar1=0;
	}
}

//==============================================
//**********************************************
// ADC_INITIAL---
// 初始化开启AD功能, 结果采用高4低8结构
// 初始化AD 输入信号为外部模拟通道输入; AD采样时钟为FSYS/8
// AD参考电压选择Vr , PGA 功能打开,  PGA输入选择VBG(1.04), PGA放大倍数*4
//==============================================
void	ADC_INITIAL()
{
	//;---------ADC 初始化配置
	/*--remark:-
	//;--------SADC0
	_start=0;					// SADC0.7---启动AD转换为-- 启动过程: 0->1->0
	_adbz;					// SADC0.6---ADC转换结束标志--1: 转换中; 0: 转换结束或未开始
	_adcen=1;					// SADC0.5---AD转换器功能使能位-- 1: AD功能使能 ; 0: AD功能关闭
	_adrfs=1;					// SADC0.4---AD结果格式-- 0：高8, 低4 ; 1: 高4 , 低8
	_sacs3=0;					// SADC0[3:0]---外部模拟通道输入选择位-- 0000: AN0 .... 1000：AN8; 1001-1111:浮空
	_sacs2=0;
	_sacs1=0;
	_sacs0=0;

	//;--------SADC1
	_sains3=0;					// SADC1.[7:4]--- AD输入信号选择位
	_sains2=0;					// 0000,0100: 外部模拟通道输入; 0001: 内部AD转换器电源VDD ; 0010: 内部AD转换器电源VDD/2 ;; 0111: 内部AD转换器电源VDD/4 ;
	_sains1=0;					// 0101: 内部PGA输出电压Vr ; 0110: 内部PGA输出电压Vr/2 ;; 0111: 内部PGA输出电压Vr/4 ;
	_sains0=0;					// 1000: 内部-SAIN1:OPA输出电压;  1001: 接地 ; 1010: 恒定电流单位增益缓冲输出  ;; 1011: 接地 ; 1100~1111: 外部模拟通道输入;

	// SADC1.3---未定义


	_sack2=0;					// SADC1[2:0]---AD采样时钟源的选择
	_sack1=0;					// 000: Fsys;  001:Fsys/2;  010:Fsys/4;  011:Fsys/8;  100:Fsys/16;  101:Fsys/32;  110:Fsys/64;  111:Fsys/128;
	_sack0=0;

	//;--------SADC2
	_adpgaen=0;				// SADC2.7--- AD转换器PGA 功能使能位-- 0: 除能 ; 1: 使能

	// SADC2[6:5]---未定义

	_pgais=0;					// SADC2.4 --  PGA 输入(Vrl)选择位-- 0: Vref ; 1:VBG
	_savrs1=0;					// SADC2[3:2] -- AD参考电压选择位 --- 00:VDD ; 01：VREF, 1x: Vr
	_savrs0=0;
	_pgags1=0;					// SADC2[1:0] -- PGA的增益选择位 --- 00: Gain=1;  01: Gain=2;  10: Gain=3;  11: Gain=4;
	_pgags0=0;
	*/

	_sadc0 = 0b00110000;			// 初始化开启AD功能, 结果采用高4低8结构
	_sadc1 = 0b00000100;			// 初始化AD 输入信号为外部模拟通道输入; AD采样时钟为FSYS/16
	//_sadc2 = 0b10011011;			// AD参考电压选择Vr , PGA 功能打开,  PGA输入选择VBG(1.04), PGA放大倍数*4
	_sadc2 =   0b00010011;			// AD参考电压选择VDD , PGA 功能关闭,

}

//==============================================
//**********************************************
// PPG_Function_INITIAL
//==============================================
void PPG_INITIAL()
{
	//;---------PPGC 配置
	/*
	//---- PPG 软件触发位
	_pst=0;					//;-- PPGC.7: PST --- 0: 停止PPG; 1: 启动PPG

	//---- SYNC 被检测到时使能/除能重新启动PPG模块输出
	_prsen=1;           //;-- PPGC.6: PRSEN --- 0: 除能 ;  1 : 使能

	//;-- PPGC.5: 未定义

	//---- PPG重新载入控制寄存器
	_rlbf=0;					//;-- PPGC.4: RLBF  --- 0: 重载值来自PPGTA ; 1: 重载值来自PPGTAB
	//
	//---- PPG计数器是否与时钟同步
	_ptsyn=0;					//;-- PPGC.3: PTSYN --- 0: 与时钟同步; 1: 与时钟异步

	//;-- PPGC.2: 未定义

	//----选择触发PPG重新启动时比较器0输出的1个边沿或者2个边沿
	//----( 该位仅适用于上升沿或下降沿 C0EG[1:0] =01 或 10 )
	_trgmod=0;					//;-- PPGC.1: -- 0: 1个边沿;  1: 2个边沿

	//----PPG时钟频率是否除以2
	_pcsd=1;					//;-- PPGC.0: -- 0: 不除以2;  1: 除以2
	*/

	_ppgc = 0b00000001;


	//;---------PPGPC 配置
	/*-- IGBTD 输出有效电平控制位 Bit 7~0 PPGPC7~PPGPC0：IGBTD 输出有效电平控制位
	01010101：IGBTD 输出低电平有效
	10101010：IGBTD 输出高电平有效
	其它值：IGBTD 输出浮空
	*/
	_ppgpc = 0b01010101;
	
	//;---------PPGTA 配置
	/*
	*/
	_ppgta = 0x80;

	//;---------PPGTB 配置
	/*
	*/
	_ppgtb = 0x80;

	//;---------PPGTEX 配置
	/*
	//-- _ppgtb8=1   PPGTEX.4 :  PPG计数器预载寄存器B 第8位
	//-- _ppgta8=1   PPGTEX.0 :  PPG计数器预载寄存器A 第8位
	*/
	_ppgtex = 0x11;

	//;---------PWLT 配置
	/*
	//-- PPG脉宽限制计数器寄存器-
	//-- 限制长度= (256-PWLT)/(fsys/2)
	*/
	_pwlt = 256-240;				//---最大长度一半 --- =_pwlt/8 uS =30uS

	/*
	//;-- PPGC.7~4: 未定义

	//----PPG 计数功能计数器溢出标志位
	_ovf=0;					//;-- PPGCTC.3: -- 0: 未溢出;  1: 溢出  ( 需要软件清除)

							//----PPG 计数功能计数器控制位
	_cton=0;					//;-- PPGCTC.2: -- 0: 停止计数 ;  1: 从0开始计数
							//--- PPG 计数值存入 SYNCBUF的时间间隔
	_cts1=0;					//;-- PPGCTC.1~0: -- 00: fHIRC/8192 =0.5ms ;  01: fHIRC/16384 =1ms ;
	_cts0=0;					//;------------------10: fHIRC/32768 =2ms ;  11: fHIRC/65536 =4ms ;
	*/
	_ppgctc=0b00000111;			//----------- 4ms
	//--- ACC = _syncbuf;			// 读取 计数值
}
//==============================================
//**********************************************
// TMR_INITIAL ---FOR 蜂鸣器驱动
//==============================================
void	PCK_INITIAL()
{
	//;---------定时器 PCKC 配置
	/*--remark:-
	_pckd=0;					// PCKC.6 --- PCK 输出控制位: 0: 无效;  1: 有效
	_pckpol=0;					// PCKC.5 --- PCK输出极性控制位: 0: 同相 ; 1: 反相
							// 当PCKD=0时, 此位为0： PCK输出LOW, 为1输出HIHG
	_pcken=1;					// PCKC.4 --- PCK 总控制位  0: 除能; 1: 使能

	_pckpsc3=0;				// PCKC[3:0]( PCKPSC[3:0])---PCK的时钟分频; 0000: FHIRC/8;     0001:FHIRC/16 ; 0010: FHIRC/24; 0011:FHIRC/32 ;
	_pckpsc2=0;				// 0100: FHIRC/40;    0101:FHIRC/48 ; 0110: FHIRC/2048;
	_pckpsc1=0; 				// 0111: FHIRC/4096 ; 1XXX: FHIRC/8192 ;
	_pckpsc0=0;
	*/

	_pckc = 0b00010111;			// 使能-无效-输出0--4KHz (16M/4096)

}
//==============================================
//**********************************************
// TMR_INITIAL ---MODE0 ( PPG不可重触发功能) 或定时器功能
//==============================================
void	TMR_INITIAL()
{
	//;---------定时器TMRC配置
	/*--remark:-
	_tm1=0;					// TMRC[7:6] --- 00: MODE0( PPG不可重触发功能) ; 10 :定时器模式 ; 其他未使用
	_tm0=0;
	_ton=1;					// TMRC.4    ---计数器运行控制位

	_tpsc2=0;					// TMRC[2:0]( TPSC[2:0])---定时器的时钟; 000: Fsys ; 001:Fsys/2 ; 010: Fsys/4;...... 111: Fsys/128
	_tpsc1=0;
	_tpsc0=0;

	*/
	_tmrc = 0x02;				 // MODE0( PPG不可重触发功能)  Fsys/4
	_tmr = 256-50;				// 不可重触发时间 = 50*4/Fsys  ( 16M =12.5uS )
}

//==============================================
//**********************************************
// CTM0_INITIAL ---
// 定义为定时器功能--2ms
//==============================================
void	CTM0_INITIAL()
{
	//;---------定时器CTM配置
	/*--remark:-
	//;--------CTM0C0
	_ct0pau=0;					// CTM0C0.7---TM0寄存器暂停位; 1: 暂停
	_ct0ck2=1;
	_ct0ck1=1;
	_ct0ck0=1;					// CTM0C0[6:4](T0CK[2:0])---TM0 时钟源; 000：Fsys/4; 001:Fsys; 010:Fh/16; 011:Fh/64; 100&101:Ftbc; 110:TCK0上升沿; 111:TCK0下降沿
	_ct0on=0;					// CTM0C0.3---计数器运行控制位

	_ct0rp2=0					// CTM0C0[2:4](CT0RP[2:0])---CCRP 匹配周期; 000: 1024*Fctm ; 001:128*Fctm ; 010: 256*Fctm;...... 111:896*Fctm
	_ct0rp1=0
	_ct0rp0=0

	//;--------CTM0C1
	_ct0m1=1;
	_ct0m0=1;					// CTM0C1[7:6](T0M[1:0])---功能选择; 00: 比较匹配输出;  01：未定义; 10: PWM模式; 11:定时计数模式
	_ct0io1=0;
	_ct0io0=0;					// CTM0C1[5:4](T0IO[1:0])---见规格书; 定时模式未使用. PWM模式---10: PWM输出
	_ct0oc=0;					// CTM0C1.3--- 输出脚初始状态; 0: 初始低/低有效； 1: 初始高/高有效
	_ct0pol=0;					// CTM0C1.2--- 输出极性; 	0： 同相	 ;  1: 反相 ---直接将CTP1输出脚状态取反
	_ct0dpx=0;					// CTM0C1.1--- 占空比/频率 比较选择; 0： CCRP周期, CCRA=占空比
	_ct0cclr=0;					// CTM0C1.0--- 计数器周期匹配; 0: CCRP匹配; 1: CCRA匹配

	*/
	_ctm0al = 500&0xff;  			// 低字节的操作, 仅在其相应的高字节操作执行时发生 //
	_ctm0ah = 500/256;			//  CCRA周期： (256*_ctm0ah + _ctm0al)个TM0时钟周期

	_ctm0c0 = 0b00110000;				// CTM0时钟： Fsys/64
	_ctm0c1 = 0b11000001;				// 定时计数模式;  CCRA匹配;  定时时间 500*4/16MHz = 125uS

	_ct0on = 1;					//  启动定时计数----启动时 TMR0DL,TMR0DH 从0开始计数

	_ade = 0;
	_ctm0pe = 0;				//  CTM0 CCRP中断功能关闭
	_ctm0ae = 1;				//  CTM0 CCRA中断功能开启
	_mf1e = 1;					//  多功能中断1 开启.

}


//==============================================
//**********************************************
// CTM1_INITIAL ---
// CCRA为16BIT寄存器, CCRP 为CTM1C1的低3BIT 选择CCRP周期
// 此处范例功能定义为PWM模式 ,CCRP 为PWM周期, CCRA 为占空比 , 操作调整占空比时即调整CCRA值不能超过 CCRP代表的周期范围
// 此处范例功能定义为定时器模式
//==============================================
void	CTM1_INITIAL()
{
	//;---------定时器CTM配置
	/*--remark:-
	//;--------CTM1C0
	_ct1pau=0;					// CTM1C0.7---TM0寄存器暂停位; 1: 暂停
	_ct1ck2=1;
	_ct1ck1=1;
	_ct1ck0=1;					// CTM1C0[6:4](T0CK[2:0])---TM0 时钟源; 000：Fsys/4; 001:Fsys; 010:Fh/16; 011:Fh/64; 100&101:Ftbc; 110:TCK0上升沿; 111:TCK0下降沿
	_ct1on=0;					// CTM1C0.3---计数器运行控制位

	_ct1rp2=0					// CTM1C0[2:4](CT0RP[2:0])---CCRP 匹配周期; 000: 1024*Fctm ; 001:128*Fctm ; 010: 256*Fctm;...... 111:896*Fctm
	_ct1rp1=0
	_ct1rp0=0

	//;--------CTM1C1
	_ct1m1=1;
	_ct1m0=1;					// CTM1C1[7:6](T0M[1:0])---功能选择; 00: 比较匹配输出;  01：未定义; 10: PWM模式; 11:定时计数模式
	_ct1io1=0;
	_ct1io0=0;					// CTM1C1[5:4](T0IO[1:0])---见规格书; 定时模式未使用. PWM模式---10: PWM输出
	_ct1oc=0;					// CTM1C1.3--- 输出脚初始状态; 0: 初始低/低有效； 1: 初始高/高有效
	_ct1pol=0;					// CTM1C1.2--- 输出极性; 0： 同相	 ;  1: 反相 ---直接将CTP1输出脚状态取反
	_ct1dpx=0;					// CTM1C1.1--- 占空比/频率 比较选择; 0： CCRP周期, CCRA=占空比
	_ct1cclr=0;					// CTM1C1.0--- 计数器周期匹配; 0: CCRP匹配; 1: CCRA匹配

	*/
	_ctm1al = 500&0xff;  			// 低字节的操作, 仅在其相应的高字节操作执行时发生 //
	_ctm1ah = 500/256;			//  CCRA占空比为 CCRA/CCRP (100/128)

	_ctm1c0  = 0x00;				// CCRP周期: 128*Fctm;  CTM1时钟：Fctm=Fsys/4
	_ctm1c1 = 0x0c1;				// PWM模式;  CCRA匹配;  CCRP:周期, CCRA为占空比;  CTP1(PWM输出脚)高有效

	_ct1on = 1;					//  启动定时器

	_ctm1pe = 0;				//  CTM1 CCRP中断功能关闭
	_ctm1ae = 1;					//  CTM1 CCRA中断功能关闭
	_mf2e = 1;					//  多功能中断5关闭.

}

#if _PWM_ENABLE == 1
//==============================================
//**********************************************
// PTM0_INITIAL ---
// PWM-- 用于驱动BUZZ:频率3.9KHz,Duty=50%
//==============================================
void PTM0_INITIAL()
{
	//;---------定时器PTM配置
	/*--remark:-
	//;--------PTM0C0
	_pt0pau=0;					// PTM0C0.7---TM0寄存器暂停位; 1: 暂停
	_pt0ck2=1;
	_pt0ck1=1;
	_pt0ck0=1;					// PTM0C0[6:4](PT0CK[2:0])---PTM0 时钟源; 000：Fsys/4; 001:Fsys; 010:Fh/16; 011:Fh/64; 100&101:Fsub; 110:PTCK0上升沿; 111:PTCK0下降沿
	_pt0on=0;					// PTM0C0.3---计数器运行控制位

	// PTM0C0[2:0]： 未定义

	//;--------PTM0C1
	_pt0m1=1;
	_pt0m0=1;					// PTM0C1[7:6](PT0M[1:0])---功能选择; 00: 比较匹配输出模式  01：捕捉输入模式; 10: PWM模式; 11:定时计数模式
	_pt0io1=0;
	_pt0io0=0;					// PTM0C1[5:4](PT0IO[1:0])---见规格书; 定时模式未使用. PWM模式---10: PWM输出
	_pt0oc=0;					// PTM0C1.3--- 输出脚初始状态; 0: 初始低/低有效； 1: 初始高/高有效
	_pt0pol=0;					// PTM0C1.2--- 输出极性; 0： 同相	;  1: 反相 ---直接将PTP0输出脚状态取反
	_pt0capts=0;				// PTM0C1.1--- PTM0 捕捉触发源 : 0: PTP0 , 1: PTCK0
	_pt0cclr=0;					// PTM0C1.0--- 计数器周期匹配; 0: CCRP匹配; 1: CCRA匹配

	*/
//	_ptm0al=1000&0xff;  			// 低字节的操作, 仅在其相应的高字节操作执行时发生 //
//	_ptm0ah=(1000/256)&0x03;		//  CCRA周期： (3*_ptm0ah + _ptm0al)个TM0时钟周期
	_ptm0al = 32;  			// 低字节的操作, 仅在其相应的高字节操作执行时发生 //
	_ptm0ah = 0;			//  CCRA周期： (3*_ptm0ah + _ptm0al)个TM0时钟周期

	_ptm0rpl = 64;  			//
	_ptm0rph = 0;  		//CCRP周期: 500*Fctm;

//	_ptm0c0=0x20;				// PTM0时钟： fH/16
	_ptm0c0 = 0b00110000;				// PTM0时钟： fH/64
	_ptm0c1 = 0b10100000;				//  定时计数模式;  CCRA匹配;  定时时间 1000*16/16MHz = 4mS//1000*64/16MHz = 4mS

//	_pt0on = 1;					//  启动定时计数

	_ptm0pe = 0;				//  PTM0 CCRP中断功能关闭
	_ptm0ae = 0;				//  PTM0 CCRA中断功能开启
	_mf0e = 0;					//  多功能中断0 开启.
}
#endif


#if	_IIC_ENABLE == 1
//==============================================
//**********************************************
// IIC_INITIAL ---
// Slave Address = 0xA0
//
//==============================================

void	IIC_INITIAL()
{
	_iica = IIC_SLAVE_ADDRESS;	// 从设备地址
	
	_iictoc=0b10111111;			// bit7 : IIC 超时功能控制位：1:功能使能  0:  除能
							// bit6 : IIC 超时标志位：1: 超时发生;  0: 未发生
							// bit5~0: IIC 超时时间 
							
	//Bit 7 HCF：I2C 总线数据传输结束标志位
		//0：数据正在被传输
		//1：8 位数据传输完成
		//数据正在传输时该位为低。当8 位数据传输完成时，此位为高并产生一个中断。
	//Bit 6 HAAS：I2C 地址匹配标志位
		//0：地址不匹配
		//1：地址匹配
		//此标志位用于决定从机地址是否与主机发送地址相同。若地址匹配此位为高，
		//否则此位为低。
	//Bit 5 HBB：I2C 总线忙标志位
		//0：I2C 总线闲
		//1：I2C 总线忙
		//当检测到START 信号时I2C 忙，此位变为高电平。当检测到STOP 信号时I2C
		//总线停止，该位变为低电平。
		//Bit 4 HTX：从机处于发送或接收模式标志位
		//0：从机处于接收模式
		//1：从机处于发送模式
	//Bit 3 TXAK：I2C 总线发送应答标志位
		//0：从机发送应答标志
		//1：从机没有发送应答标志
		//单片机接收8 位数据之后会将该位在第九个时钟时传到总线上。如果从机想要
		//接收更多的数据，则应在接收数据之前将此位设置为“0”。
		//Bit 2 SRW：I2C 从机读/ 写位
		//0：从机应处于接收模式
		//1：从机应处于发送模式
		//SRW 位是从机读写位。决定主机是否希望传输或接收来自I2C 总线的数据。当
		//传输地址和从机的地址相同时，HAAS 位会被设置为高，从机将检测SRW 位来
		//决定进入发送模式还是接收模式。如果SRW 位为高时，主机会请求从总线上读
		//数据，此时从机处于传输模式。当SRW 位为“0”时，主机往总线上写数据，
		//从机处于接收模式以读取该数据。
	//Bit 1 IAMWU：I2C 地址匹配唤醒控制位
		//0：除能
		//1：使能
		//此位应设置为“1”使能I2C 地址匹配以使系统从休眠模式或空闲模式中唤醒。
		//若进入休眠模式或空闲模式前IAMWU 已经置高以使能I2C 地址匹配唤醒功能，
		//在系统唤醒后须软件清除此位以确保单片机正确地运行。
	//Bit 0 RXAK：I2C 总线接收应答标志位
		//0：从机接收到应答标志
		//1：从机没有接收到应答标志
		//RXAK位是接收应答标志位。如果RXAK位被重设为“0”即8 位数据传输之后，
		//从机在第九个时钟有接受到一个应答信号。如果从机处于发送状态，从机作为
		//发送方会检查RXAK 位来判断主机接收方是否愿意继续接收下一个字节。因此
		//发送方会一直发送数据，直到RXAK 为“1”时才停止发送数据。这时，发送
		//方将释放SDA 线，主机方可发出停止信号从而释放I2C 总线。
	_iicc1=0b00000000;			// 在IIC打前需要初始化为0 // IIC地址匹配唤醒控制位-- 0: 除能; 1: 使能 ---IIC正常工作时要除能
	
	_iicc0=0b00000110;			// bit3~2: IIC 去抖时间: 00:无去抖; 01: 2*Fsys ; 1*: 4*Fsys
							// bit1 : IIC 功能控制位：1:功能使能;  0: 除能
		       	
	_iice=1;					// 中断使能
}
#endif

#if	_UART_ENABLE == 1
//==============================================
//**********************************************
// UART_INITIAL ---
// Bandrate ：9600bps @16Mhz
//
//==============================================
void	UART_INITIAL()
{
	_pbs0 = 0b00001111;	//pb0 as tx; pb1 as rx
	//------- USR Register ----------------------------------------------------------------------------
	_u0sr=0b00001011;
	//Name	PERR NF FERR OERR RIDLE RXIF TIDLE TXIF
	//R/W	R R R R R R R R
	//POR	0 0 0 0 1 0 1 1
	//Bit 7 PERR：奇偶校验出错标志位
		//0：奇偶校验正确
		//1：奇偶校验出错
		//PERR 是奇偶校验出错标志位。若PERR=0，奇偶校验正确；若PERR=1，接收
		//到的数据奇偶校验出错。只有使能了奇偶校验此位才有效。可使用软件清除该
		//标志位，即先读取USR 寄存器再读TXR_RXR 寄存器来清除此位。
	//Bit 6 NF：噪声干扰标志位
		//0：没有受到噪声干扰
		//1：受到噪声干扰
		//NF 是噪声干扰标志位。若NF=0，没有受到噪声干扰；若NF=1，UART 接收数
		//据时受到噪声干扰。它与RXIF 在同周期内置位，但不会与溢出标志位同时置
		//位。可使用软件清除该标志位，即先读取USR 寄存器再读TXR_RXR 寄存器将
		//清除此标志位。
	//Bit 5 FERR：帧错误标志位
		//0：无帧错误发生
		//1：有帧错误发生
		//FREE 是帧错误标志位。若FREE=0，没有帧错误发生；若FREE=1，当前的数
		//据发生了帧错误。可使用软件清除该标志位，即先读取USR 寄存器再读TXR_
		//RXR 寄存器来清除此位。
	//Bit 4 OERR：溢出错误标志位
		//0：无溢出错误发生
		//1：有溢出错误发生
		//OERR 是溢出错误标志位，表示接收缓冲器是否溢出。若OERR=0，没有溢出
		//错误；若OERR=1，发生了溢出错误，它将禁止下一组数据的接收。可通过软
		//件清除该标志位，即先读取USR 寄存器再读TXR_RXR 寄存器将清除此标志位。
	//Bit 3 RIDLE：接收状态标志位
		//0：正在接收数据
		//1：接收器空闲
		//RIDLE 是接收状态标志位。若RIDLE=0，正在接收数据；若RIDLE=1，接收
		//器空闲。在接收到停止位和下一个数据的起始位之间，RIDLE 被置位，表明
		//UART 空闲，RX 脚处于逻辑高状态。
	//Bit 2 RXIF：接收寄存器状态标志位
		//0：TXR_RXR 寄存器为空
		//1：TXR_RXR 寄存器含有有效数据
		//RXIF 是接收寄存器状态标志位。当RXIF=0，TXR_RXR 寄存器为空； 当
		//RXIF=1，TXR_RXR 寄存器接收到新数据。当数据从移位寄存器加载到TXR_
		//RXR 寄存器中，如果UCR2 寄存器中的RIE=1，则会触发中断。当接收数据时
		//检测到一个或多个错误时，相应的标志位NF、FERR 或PERR 会在同一周期内
		//置位。读取USR 寄存器再读TXR_RXR 寄存器，如果TXR_RXR 寄存器中没有
		//新的数据，那么将清除RXIF 标志。
	//Bit 1 TIDLE：数据发送完成标志位
		//0：数据传输中
		//1：无数据传输
		//TIDLE 是数据发送完成标志位。若TIDLE=0，数据传输中。当TXIF=1 且数据
		//发送完毕或者暂停字被发送时，TIDLE 置位。TIDLE=1，TX 引脚空闲且处于逻
		//辑高状态。读取USR 寄存器再写TXR_RXR 寄存器将清除TIDLE 位。数据字
		//符或暂停字就绪时，不会产生该标志位。
	//Bit 0 TXIF：发送数据寄存器TXR_RXR 状态位
		//0：数据还没有从缓冲器加载到移位寄存器中
		//1：数据已从缓冲器加载到移位寄存器中(TXR_RXR 数据寄存器为空)
		//TXIF 是发送数据寄存器为空标志位。若TXIF=0，数据还没有从缓冲器加载到
		//移位寄存器中；若TXIF=1，数据已从缓冲器中加载到移位寄存器中。读取USR
		//存器再写TXR_RXR 寄存器将清除TXIF。当TXEN 被置位，由于发送缓冲器未
		//满，TXIF 也会被置位。
		
	//------- UCR1 Register ----------------------------------------------------------------------------
	_u0cr1 = 0b10000000;				//长度 8bit
	//Name	UARTEN BNO PREN PRT STOPS TXBRK RX8 TX8
	//R/W	R/W R/W R/W R/W R/W R/W R W
	//POR	0 0 0 0 0 0 x 0
	//Bit 7 UARTEN：UART 功能使能位
		//0：UART 除能，RX 和 TX 可用作普通输入/ 输出口
		//1：UART 使能，TX 和RX 脚作为UART 功能引脚
		//此位为UART 的使能位。UARTEN=0，UART 除能，RX 和 TX 可用作普通输入
		/// 输出口；UARTEN=1，UART 使能，TX 和RX 将分别由TXEN 和RXEN 控制。
		//当UART 被除能将清除缓冲器，所有缓冲器中的数据将被忽略，另外波特率计
		//数器、错误和状态标志位被复位，TXEN、RXEN、TXBRK、RXIF、OERR、
		//FERR、PERR 和NF 清零，而TIDLE、TXIF 和RIDLE 置位，UCR1、UCR2 和
		//BRG 寄存器中的其它位保持不变。若UART 工作时UARTEN 清零，所有发送
		//和接收将停止，模块也将复位成上述状态。当UART 再次使能时，它将在上次
		//配置下重新工作。
	//Bit 6 BNO：发送数据位数选择位
		//0：8-bit 传输数据
		//1：9-bit 传输数据
		//BNO 是发送数据位数选择位。BNO=1，传输数据为9 位；BNO=0，传输数据为
		//8 位。若选择了9 位数据传输格式，RX8 和TX8 将分别存储接收和发送数据的
		//第9 位。
		//注：1. 若BNOn =1(9-bit 数据传输格式)，奇偶校验使能时，数据的9th data 为
		//奇偶校验位，不会传送到RX8.
		//2. 若BNOn =0(8-bit 数据传输格式)，奇偶校验使能时，数据的8th data 为
		//奇偶校验位，不会传送到RX7.
	//Bit 5 PREN：奇偶校验使能位
		//0：奇偶校验除能
		//1：奇偶校验使能
		//此位为奇偶校验使能位。PREN=1，使能奇偶校验；PREN=0，除能奇偶校验。
	//Bit 4 PRT：奇偶校验选择位
		//0：偶校验
		//1：奇校验
		//奇偶校验选择位。PRT=1，奇校验；PRT=0，偶校验。
	//Bit 3 STOPS：停止位的长度选择位
		//0：有一位停止位
		//1：有两位停止位
		//此位用来设置停止位的长度。STOP=1，有两位停止位；STOP=0，只有一位停
		//止位。
	//Bit 2 TXBRK：暂停字发送控制位
		//0：没有暂停字要发送
		//1：发送暂停字
		//TXBRK 是暂停字发送控制位。TXBRK=0，没有暂停字要发送，TX 引脚正常
		//操作；TXBRK=1，将会发送暂停字，发送器将发送逻辑“0”。若TXBRK 为
		//高，缓冲器中数据发送完毕后，发送器输出将至少保持13 位宽的低电平直至
		//TXBRK 复位。
	//Bit 1 RX8：接收9-bit 数据传输格式中的第9 位( 只读)
		//此位只有在传输数据为9 位的格式中有效，用来存储接收数据的第9 位。BNO
		//是用来控制传输位数是8 位还是9 位。
	//Bit 0 TX8：发送9-bit 数据传输格式中的第9 位( 只写)
		//此位只有在传输数据为9 位的格式中有效，用来存储发送数据的第9 位。BNO
		//是用来控制传输位数是8 位还是9 位。
		
	//------- UCR2 Register ----------------------------------------------------------------------------
	_u0cr2 = 0b11000100;//0xc4; 				//开接收中断 
	//Name	TXEN RXEN BRGH ADDEN WAKE RIE TIIE TEIE
	//R/W	R/W R/W R/W R/W R/W R/W R/W R/W
	//POR	0 0 0 0 0 0 0 0
	//Bit 7 TXEN：UART 发送使能位
		//0：UART 发送除能
		//1：UART 发送使能
		//此位为发送使能位。TXEN=0，发送将被除能，发送器立刻停止工作。另外
		//发送缓冲器将被复位，此时TX 可用作普通输入/ 输出口。若TXEN=1 且
		//UARTEN=1，则发送将被使能，TX 引脚将由UART 来控制。在数据传输时清
		//除TXEN 将中止数据发送且复位发送器，此时TX 可用作普通输入/ 输出口。
	//Bit 6 RXEN：UART 接收使能位
		//0：UART 接收除能
		//1：UART 接收使能
		//此位为接收使能位。RXEN=0，接收将被除能，接收器立刻停止工作。另外
		//接收缓冲器将被复位，此时RX 可用作普通输入/ 输出口。若RXEN=1 且
		//UARTEN=1，则接收将被使能，RX 引脚将由UART 来控制。在数据传输时清
		//除RXEN 将中止数据接收且复位接收器，此时RX 可用作普通输入/ 输出口。
	//Bit 5 BRGH：波特率发生器高低速选择位
		//0：低速波特率
		//1：高速波特率
		//此位为波特率发生器高低速选择位，它和BRG寄存器一起控制UART的波特率。
		//BRGH=1，为高速模式；BRGH=0，为低速模式。
	//Bit 4 ADDEN：地址检测使能位
		//0：地址检测除能
		//1：地址检测使能
		//此位为地址检测使能和除能位。ADDEN=1，地址检测使能，此时数据的第8 位
		//(BNO=0) 或第9 位(BNO=1) 为高，那么接到的是地址而非数据。若相应的中断
		//使能且接收到的值最高位为1，那么中断请求标志将会被置位，若地址检测功能
		//使能且最高位为0，那么将不会产生中断且收到的数据也会被忽略。
	//Bit 3 WAKE：RX 脚下降沿唤醒UART 功能使能位
		//0：RX 脚下降沿唤醒UART 功能除能
		//1：RX 脚下降沿唤醒UART 功能使能
		//此位用于控制RX 引脚下降沿时是否唤醒UART 功能。此位仅当UART 时钟源
		//fH 关闭时有效。若UART 时钟源fH 还开启，则无RX 引脚唤醒UART 功能无效。
		//若此位置高且UART 时钟fH 关闭，当RX 引脚发生下降沿时会产生UART 唤醒
		//请求。若相应的中断使能，将产生RX 引脚唤醒UART 的中断，以告知单片机
		//使其通过应用程序开启UART 时钟源fH，从而唤醒UART 功能。否则，若此位
		//为低，即使RX 引脚发生下降沿也无法恢复UART 功能。
	//Bit 2 RIE：接收中断使能位
		//0：接收中断除能
		//1：接收中断使能
		//此位为接收中断使能或除能位。若RIE=1，当OERR 或RXIF 置位时，UART 的
		//中断请求标志置位；若RIE=0，UART 中断请求标志不受OERR 和RXIF 影响。
	//Bit 1 TIIE：发送器空闲中断使能位
		//0：发送器空闲中断除能
		//1：发送器空闲中断使能
		//此位为发送器空闲中断的使能或除能位。若TIIE=1，当发送器空闲触发TIDLE
		//置位时，UART 的中断请求标志置位；若TIIE=0，UART 中断请求标志不受
		//TIDLE 的影响。
	//Bit 0 TEIE：发送寄存器为空中断使能位
		//0：发送寄存器为空中断除能
		//1：发送寄存器为空中断使能
		//此位为发送寄存器为空中断的使能或除能位。若TEIE=1，当发送器为空触发
		//TXIF 置位时，UART 的中断请求标志置位；若TEIE=0，UART 中断请求标志不
		//受TXIF 的影响。
		
	//------- USR Register ----------------------------------------------------------------------------
	_brgh0 = 0;
	_brg0 = 25;		// 25 = 16000000/64/9600 -1
	//Bit 7~0 BRG7~BRG0：波特率值
	//软件设置BRGH 位( 设置波特率发生器的速度) 和BRG 寄存器( 设置波特率的
	//值)，一起控制UART 的波特率。
	//注：若BRGH=0，波特率= fH/[64×(N+1)]；
	//	 若BRGH=1，波特率= fH/[16×(N+1)]。
		       	
	_ur0e=1;					// 中断使能
}
#endif

//===============================================================
//function: void user_initial(void).
//input   : NULL.
//output  : NULL
//description: 初始化一下系统设置和变量等.
//===============================================================
void user_initial(void)
{
C_DETE_BATV_LOOP:	
	P_OPEN_C = 0;
	P_OPEN = 0;/* 关闭电池供电 */
	P_LOAD_C = 0;
	P_LOAD = 0;
	P_BAT_C = 1;//打开电池电压检测.
	
	#if _PWM_ENABLE == 1
	_pas07 = 0;
	_pas06 = 1;
	/* PWM */
	_ptm0af=0;
	_ptm0pf=0;
	_tb0f=0;
	_pt0on = 1;					//  启动定时计数
	_ptm0pe = 0;				//  PTM0 CCRP中断功能关闭
	_ptm0ae = 0;				//  PTM0 CCRA中断功能开启
	_mf0e = 0;					//  多功能中断0 开启.
	#endif
	
	/* 定时 */
	_ctm0af=0;
	_ctm0pf=0;
	_adf=0;
	_ct0on = 1; 				//	启动定时计数----启动时 TMR0DL,TMR0DH 从0开始计数
	_ctm0pe = 0;				//	CTM0 CCRP中断功能关闭
	_ctm0ae = 1;				//	CTM0 CCRA中断功能开启
	_mf1e = 1;					//	多功能中断1 开启.

	_emi = 1;
	
	/* opa */
	_opac0 = 0b10100100;			//--OPA Enable;  x20; SWR2:On;	外部反馈电路
	_aofm = 0;//运算放大器模式.
	_ars = 0;//反向输入.
	//pc0:IS1
	_pcs01 = 1;
	_pcs00 = 1;
	
	R_time200ms = C_200MS_COUNT;
	R_time3s = 0;
	f_flagtime_byte = 0x00;
	f_flag0_byte = 0x00;
	f_flag1_byte = 0x00;
	f_flag2_byte = 0x00;
	f_flag3_byte = 0x00;

	/* 开机方式检测:VIN或按键开机*/
	if(P_VINCHK){
		f_3s = 0;
		/* 当没插VIN供电,按按键3s后开机 */
		while(!f_3s){
			GCC_CLRWDT();
		}
		f_3s = 0;
		f_keypress = 1;
		R_workmode = C_DISCHARGE_MODE;
	}else{
		f_vin_on = 1;
		R_workmode = C_CHARGE_MODE;
	}
	
	f_charge_init = 1;
	f_discharge_init = 1;
	f_safetyinit = 1;
	User_config_Read();

	f_adc_ok = 0;
	R_ADC_Count = 0;
	R_intADC_Sum = 0;
	R_adc_channel = C_Vbat_AN5;
	_sadc0 = C_Vbat_AN5;
	_sadc1 = C_EXTERNAL_CHN;
	while(!f_adc_ok){
		GetBattery_Level();
	}
	/*1:按键开机电池电压<12.5不开机; 2:适配器开机时电池电压<12.5不打开输出.*/
	if(C_BATV_12V5 > R_intADC_Vbat){
		if(!f_vin_on)
			goto C_DETE_BATV_LOOP;
	}else{
		P_OPEN = 1;
		P_LOAD = 1;
	}
}


